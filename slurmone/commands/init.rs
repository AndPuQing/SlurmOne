use std::error::Error;
use std::path::Path;

use crate::common::{arg::InitArgs, config::Config};

static SCRIPT: &str = r#"#!/bin/bash
# SlurmOne script generated by SlurmOne CLI
#SBATCH --job-name=slurmone
# Sets the job name to "slurmone" for easy identification in the job queue.

#SBATCH --gres=gpu:1
# Requests 1 GPU resource. Adjust the number based on task requirements.

#SBATCH --time=1:00:00
# Sets the maximum runtime of the job to 1 hour in the format "hours:minutes:seconds".
# If not set, the job will run indefinitely.
# Warning: The job will be terminated if it exceeds this limit.

#SBATCH --output=slurmone.stdout.log
# Specifies the log file for standard output as "slurmone.out".

#SBATCH --error=slurmone.stderr.log
# Specifies the log file for standard error as "slurmone.err".

#SBATCH --workdir=.
# Sets the working directory for the job to the current directory, defaulting to where the job is submitted.

#SBATCH --conda-env=base
# Specifies the Conda environment to use as "base". This requires cluster support for loading Conda environments.

echo "Hello, SlurmOne!"
"#;

pub async fn handle_init(args: InitArgs, _config: &Config) -> Result<(), Box<dyn Error>> {
    let mut file_path = args.file.unwrap_or_else(|| "./slurmone.sh".to_string());
    if Path::new(&file_path).exists() {
        eprintln!("File already exists: {}", file_path);
        return Ok(());
    }
    if !file_path.ends_with(".sh") {
        file_path.push_str(".sh");
    }

    std::fs::write(&file_path, SCRIPT)?;
    Ok(())
}
